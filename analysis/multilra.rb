#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'mongo'
require 'pp'
require 'logger'
require 'analysis/TSAnal'
require 'date'
require 'eostruct'
require 'statsample'

logger = Logger.new('/var/log/embracer/multilra.log')
logger.level = Logger::DEBUG

=begin rdoc
= Multi Linear Regression Analysis

mLRA computes LRA over multiple sample sizes of powers of 2. Same is done for
the volume.

We could do this strictly as a function of time or tick sequences. We choose
to do it as tick sequencing instead. Later we may become more sophisticated.

Indeed, we will be storing these results over the power spectral vector:

{beta1, beta0, sigma, hourStamp, minuteStamp, duration, velocityT, velocityC}

Where:
* beta1 and beta0 correspond to the regression line
* sigma corresponds to the SD over the sample.
* hourStamp corresponds to the number of hours since midnight at the end of
  the interval.
* minuteStamp corresponds to the number of minutes since the hour at the end of the interval.
* duration corresponds to the number of seconds in the tick interval sampled.
* velocityT corresponds to the "trades per minute" as calculated by the 
  difference in time interval divided by the number of trades 
* velocityC corresponds to the "contracts per minute" as calculated by the 
  difference in time interval divided by the number of contracts

== Conventions

We shall set the y line at current, so beta0 will correspond to intercept
at current time, since all samples will begin from current time and extend
backwards into the past. This way, if we change powN, beta0 will not require
modification. 

By the same token, the index of the tick shall be taken as zero for the current
time, and extend positive into the past, negative into the future. This is to
simplify the math a bit, and kinda makes sense from a conceptual/intuitive perspective,
since our ultimate goal is to predict what will happen at t=-1, -2, etc. This
will simplify how we handle offsets on the multiple scales of our power spectrum.

== Things to note

There will be a tremdous amout of data generated by MultiLRA for any given
instrument. 

=end
module MultiLRA
  # This class derives from Bobbin, and runs a couple of threads
  # to gather the data and run the analysis.
  class MultiLRABobbin < TSAnal::Bobbin

    # mmarket -- collection for market data(source)
    # mmlra   -- collection for analysis (destination) 
    # symbol  -- symbol to analyze
    # startDT -- start time
    # endDT   -- end time  
    def initialize(powN, mmarket, mmlra, symbol, startDT, endDT)
      super(symbol, startDT, endDT)
      
      # pow N sample collection
      @powN = powN
      @ticks = [] # shall hold 2 ** @powN entries for analysis

      # Collections
      @market = mmarket
      @mLRA = mmlra
    end
    
    # Iterator for incoming data
    def spool 
      @market.find(symbol: @symbol, 
                   stamp: {:$gte => @startDT, :$lt => @endDT}) { |cursor|
        cursor.each { |datum|
          yield datum
        }
      }
    end

    # Actual analysis happens here. We compute the following
    # for multiple range cumulation:
    # [{interval,
    #   beta1,   beta0,   sigma,   corr,   mean, # last trade price/index
    #   c_beta1, c_beta0, c_sigma, c_corr, c_mean, # contracts
    #   hourStamp, minuteStamp, # time channel info
    #   duration, velocityT, velocityC}, ...]
    #
    # We do the LRA based on time in seconds within the sample.
    def needle(datum)
      multi = []
      pN = 2 ** @powN
      @ticks.unshift datum # we want the most recent first!!
      @ticks.pop unless @ticks.size <= pN 
      @powN.times { |pi|
        lra = {}
        interval = 2 ** (pi + 1)
        sample = @ticks[0, interval]
        lra[:interval] = interval
        lra[:duration] = [1, sample.first["stamp"] - sample.last["stamp"]].max
        minutes = (lra[:duration] / 60.0)
        lra[:velocityT] = sample.size / minutes
        lra[:velocityC] = sample.reduce(0) {|memo, d| memo + d["size"]} / minutes
        stamp = sample.first["stamp"]
        lra[:hourStamp] = stamp.hour
        lra[:minuteStamp] = stamp.min

        ## Now do the *real* stats!!!!
        if true
          vlast = sample.map{|d| d['last']}.to_scale
          vcontracts = sample.map{|d| d['size']}.to_scale
          vtime =  sample.map{|d|sample.first['stamp'] - d['stamp']}.to_scale
          rlast = Statsample::Regression::Simple.new_from_vectors(vlast, vtime)
          rcontracts = Statsample::Regression::Simple.new_from_vectors(vcontracts, vtime)
          
          # For the last price
          lra[:beta0] = rlast.a 
          lra[:beta1] = rlast.b
          lra[:corr] = rlast.r
          lra[:sigma] = vlast.sd
          lra[:mean] = vlast.mean
          
          # For the contract volume
          lra[:c_beta0] = rcontracts.a 
          lra[:c_beta1] = rcontracts.b
          lra[:c_corr] = rcontracts.r
          lra[:c_sigma] = vcontracts.sd
          lra[:c_mean] = vcontracts.mean
        end

        multi << lra
      } unless @ticks.size < pN

      # Store multi in database
      unless multi.empty?
        datum[:multi] = multi
        # @mLRA.save datum
        puts " tick %s:%s" % [datum["symbol"], datum["stamp"]] if $gopts.verbose
        puts "<< %s" % datum if $gopts.debug
      end
      
      nil # FIXME: We have a memory leak somewhere...
    end
  end
end

########################################################################
## Command-line interface to run multiLRA
########################################################################
if __FILE__ == $0
  # Standard Options
  $gopts = OpenStruct.new
  $gopts.verbose = false
  $gopts.debug = false
  $gopts.warn = true
  $gopts.noop = false
  $gopts.days = 20
  $gopts.powN = 12

  OptionParser.new do |opts|
    opts.banner = %{
Usage: multilra [options]

Multi Linear Regression Analysis -- Compute a multiLRA for (a) given tick symbol(s) 
and place the results in the analysis.multiLRA Mongo collection. 

The LRA is not only computed for the index(price), but also for the volume. The
results are stored in [LRAi, LRAv] for each sample size

}
    opts.on("-D", "--days DAYS", "Warnings (default)") { |v| $gopts.days = v.to_i }
    opts.on("-P", "--pown PN", "Power of N sample sizes (default %d)" % $gopts.powN) { |v| 
      $gopts.powN = v.to_i }
    opts.on("-v", "--[no-]verbose", "Verbose output to stdout") { |v| $gopts.verbose = v  }
    opts.on("-d", "--debug", "Debug output (extensive)") { |v| $gopts.debug = v }
    opts.on("-w", "--[no-]warn", "Warnings (default)") { |v| $gopts.warn = v }
  end.parse!
  
  symbols = ARGV
  $gopts.verbose = $gopts.warn = true if $gopts.debug
  $gopts.etime = DateTime.now
  $gopts.btime = $gopts.etime - $gopts.days

  puts "MultiLRA Analysis for symbols %s over time period %s to %s" % [symbols, 
                                                                       $gopts.btime.to_time, 
                                                                       $gopts.etime.to_time]

  ## Set up mLRA collection
  market = Mongo::Connection.new("localhost").db("market")[:market]
  mLRA = Mongo::Connection.new("localhost").db("analysis")[:multiLRA]
  mLRA.create_index([
                     [:symbol, Mongo::ASCENDING],
                     [:stamp, Mongo::ASCENDING],
                     [:tick_id, Mongo::ASCENDING]
                    ], unique: true)

  ## Analysis
  symbols.each { | symbol |
    puts "multiLRA: Analyzing %s" % symbol
    MultiLRA::MultiLRABobbin.new($gopts.powN, 
                                 market, mLRA, 
                                 symbol, 
                                 $gopts.btime, $gopts.etime).run()
  }
end
